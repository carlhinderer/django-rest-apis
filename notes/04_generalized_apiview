----------------------------------------------------------------
CHAPTER 4 - USING GENERALIZED BEHAVIOR FROM THE APIVIEW CLASS
----------------------------------------------------------------

- Taking Advantage of Model Serializers

    - We can use leverage the fact that the 'rest_framework.serializers.ModelSerializer'
        automatically populates default vales and default validators, along with providing
        default implementations for the 'create' and 'update' methods.

      We'll subclass our serializer from this class instead of 'serializers.Serializer' to 
        get this behavior.


        # restful01/toys/serializers.py
        from rest_framework import serializers
        from toys.models import Toy

        class ToySerializer(serializers.ModelSerializer):
            class Meta:
                model = Toy
                fields = ('id',
                          'name',
                          'description',
                          'release_date',
                          'toy_category',
                          'was_included_in_home')



    - The 'model' attribute specifies the model class related to the serializer.
      The 'fields' attribute specifies the list of fields we want to be included in serialization.



- Understanding Accepted and Returned Content Types

    - So far, our web service has been using JSON for the response body.  Our existing 
        ApiView class declares a JSONResponse and 2 function-based views.  

      Those functions:
        - return a JSONResponse when it is necessary to return a JSON response
        - return an HTTPResponse when the response is just a HTTP status code


    - Right now, even if we send a request to our web services with 'Accept: application/html',
        they would still return results with 'Content-Type: application/json'.  We don't provide
        support for other formats yet.

        # Returns json response
        $ http :8000/toys/ Accept:application/json
        $ curl -H "Accept: application/json" -iX GET localhost:8000/toys/

        # Still returns json response
        $ http :8000/toys/ Accept:text/html
        $ curl -H "Accept: text/html" -iX GET localhost:8000/toys/

        # Either way the response has this header
        Content-Type: application/json



- Making Unsupported HTTP OPTIONS Requests

    - Sometimes, we don't know which HTTP methods a resource supports.  To find out, we can
        send an HTTP OPTIONS request.  

        # Get which HTTP verbs are supported, these will fail
        $ http OPTIONS :8000/toys/
        $ curl -iX OPTIONS localhost:8000/toys/

        # These will also fail
        $ http OPTIONS :8000/toys/2
        $ curl -iX OPTIONS localhost:8000/toys/2


    - The requests fail currently, and the stack trace of what went wrong is returned.  Note that
        the stack traces are only returned because we have 'debug' set to true, and this must be
        turned off in production.



- Understanding Decorators 

    - We want to make our app respond to OPTIONS requests.  To do this, we take advantage of
        the '@api_view' decorator declared in the 'rest_framework.decorators' module.

      The '@api_view' decorator allows us to specify which HTTP verbs can be processed by 
        each function.  If a verb isn't included in the 'http_method_names' argument passed in,
        a HTTP 405 'Method Not Allowed' status code will be sent in the response.


    - This will ensure we don't have an unexpected error in Django when an invalid verb name is
        passed in.


    - The 'api_view' decorator is a wrapper that converts a function-based view into a subclass
        of 'rest_framework.views.APIView' class.



- Using the Decorator

    We'll change the 'restful01/toys/views.py' file to use the 'api_view' decorator.  Note that
      we've also gotten rid of the 'JSONResponse' class definition.

    # restful01/toys/views.py
    from django.shortcuts import render 
    from rest_framework import status 
    from toys.models import Toy 
    from toys.serializers import ToySerializer
    from rest_framework.decorators import api_view 
    from rest_framework.response import Response 
     
     
    @api_view(['GET', 'POST']) 
    def toy_list(request): 
        if request.method == 'GET': 
            toys = Toy.objects.all() 
            toys_serializer = ToySerializer(toys, many=True) 
            return Response(toys_serializer.data) 
     
        elif request.method == 'POST': 
            toy_serializer = ToySerializer(data=request.data) 
            if toy_serializer.is_valid(): 
                toy_serializer.save() 
                return Response(toy_serializer.data, status=status.HTTP_201_CREATED) 
            return Response(toy_serializer.errors, status=status.HTTP_400_BAD_REQUEST) 
     
     
    @api_view(['GET', 'PUT', 'DELETE']) 
    def toy_detail(request, pk): 
        try: 
            toy = Toy.objects.get(pk=pk) 
        except Toy.DoesNotExist: 
            return Response(status=status.HTTP_404_NOT_FOUND) 
     
        if request.method == 'GET': 
            toy_serializer = ToySerializer(toy) 
            return Response(toy_serializer.data) 
     
        elif request.method == 'PUT': 
            toy_serializer = ToySerializer(toy, data=request.data) 
            if toy_serializer.is_valid(): 
                toy_serializer.save() 
                return Response(toy_serializer.data) 
            return Response(toy_serializer.errors, status=status.HTTP_400_BAD_REQUEST) 
     
        elif request.method == 'DELETE': 
            toy.delete() 
            return Response(status=status.HTTP_204_NO_CONTENT)



- Updated Functions

    - The new code applies the '@api_view' decorator for both functions.  In addition, the 
        new code removes the 'JSONResponse' class and uses the more generic 
        'rest_framework.response.Response' class.


    - We got rid of the 'rest_framework.parsers.JSONParser' so that different parsers can be used
        for different content.  The new code replaces these lines:

        # Old serialization
        toy_data = JSONParser().parse(request)
        toy_serializer = ToySerializer(data=toy_data)

        # New serialization
        toy_serializer = ToySerializer(data=request.data)



- Taking Advantage of Content Negotiation Classes

    - The 'APIView' class defines default settings for each view that we can override by 
        specifying the desired values in the settings module ('restful01/settings.py').  It is
        also possible to override these class attributes in subclasses.

      In this case, we won't change any of the defaults, but let's look at one of them:

        # Value of DEFAULT_PARSER_CLASSES setting
        ( 
            'rest_framework.parsers.JSONParser', 
            'rest_framework.parsers.FormParser', 
            'rest_framework.parsers.MultiPartParser' 
        ) 


    - When we use the '@api_view' decorator, the RESTful web service will be able to handle any
        of these content types:

        'application/json'                   # Parsed by 'rest_framework.parsers.JSONParser'
        'application/x-www-form-urlencoded'  # Parsed by 'rest_framework.parsers.FormParser'
        'multipart/form-data'                # Parsed by 'rest_framework.parsers.MultiPartParser'


    - When we access the 'request.data' attribute in the functions, the Django REST framework
        examines the value of the 'Content-Type' header in the incoming request and determines
        the appropriate parser to parse the request content.


    - The default renderer classes is similar:

        # Value of DEFAULT_RENDERER_CLASSES
        ( 
            'rest_framework.renderers.JSONRenderer', 
            'rest_framework.renderers.BrowsableAPIRenderer', 
        ) 

      We can render these content types:

        'application/json'                 # Rendered by 'rest_framework.response.JSONRenderer'
        'text/html'                        # Rendered by 'rest_framework.response.BrowsableAPIRenderer'



    - By default, the value for 'DEFAULT_CONTENT_NEGOTIATION_CLASS' is 
        'rest_framework.negotiation.DefaultContentNegotiation'.  When we use the decorator, the web
        service will use the content negotiator to select the appropriate renderer for the response,
        based on the incoming request.

      That way, when a request specifies that it will accept 'text/html', the content negotiation
        class will select the 'BrowsableAPIRenderer' to render the response and generate 'text/html'
        instead of 'application/json'.